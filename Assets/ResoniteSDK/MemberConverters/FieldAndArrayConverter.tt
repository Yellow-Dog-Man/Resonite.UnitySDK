<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>

// AUTOGENERATED!!! Do not modify! Your changes will be lost after .tt template regenerates.
// Modify the .tt template instead!

<#
HashSet<string> nonNullableTypes = new HashSet<string>()
{
    "string",
    "Uri",
};

List<string> unityPrimitives = new List<string>()
{
    "Vector2",
    "Vector3",
    "Vector4",

    "Quaternion",

    "Vector2Int",
    "Vector3Int",

    "Matrix4x4",

    "Color",
    "Color32",

    "Rect",
    "RectInt",
    "Bounds",

    // Custom extensions
    "QuaternionDouble",
    "ColorX",

    "Vector2Bool",
    "Vector3Bool",
    "Vector4Bool",

    "Vector2Byte",
    "Vector3Byte",
    "Vector4Byte",

    "Vector2Ushort",
    "Vector3Ushort",
    "Vector4Ushort",

    "Vector2Uint",
    "Vector3Uint",
    "Vector4Uint",

    "Vector2Ulong",
    "Vector3Ulong",
    "Vector4Ulong",

    "Vector2Sbyte",
    "Vector3Sbyte",
    "Vector4Sbyte",

    "Vector2Short",
    "Vector3Short",
    "Vector4Short",

    "Vector2Long",
    "Vector3Long",
    "Vector4Long",

    "Vector2Double",
    "Vector3Double",
    "Vector4Double",

    "Matrix2x2",
    "Matrix3x3",

    "Matrix2x2Double",
    "Matrix3x3Double",
    "Matrix4x4Double",
};

List<string> standaloneTypes = new List<string>
{
    "byte",
    "ushort",
    "uint",
    "ulong",

    "sbyte",
    "short",
    "int",
    "long",

    "float",
    "double",

    "decimal",

    "bool",

    "char",
    "string",
    "Uri",

    "DateTime",
    "TimeSpan",

    "color",
    "colorX",
    "color32",

    "Rect",
    "IntRect",
    "BoundingBox",
};

List<string> vectorTypes = new List<string>
{
    "float",
    "double",

    "byte",
    "ushort",
    "uint",
    "ulong",

    "sbyte",
    "short",
    "int",
    "long",

    "bool",
};

List<string> quaternionTypes = new List<string>
{
    "float",
    "double",
};

List<string> matrixTypes = new List<string>
{
    "float",
    "double",
};

List<string> primitiveTypes = new List<string>();

primitiveTypes.AddRange(standaloneTypes);

for(int dim = 2; dim <= 4; dim++)
    primitiveTypes.AddRange(vectorTypes.Select(v => v + dim));

primitiveTypes.AddRange(quaternionTypes.Select(v => v + "Q"));

for(int dim = 2; dim <= 4; dim++)
    primitiveTypes.AddRange(matrixTypes.Select(v => $"{v}{dim}x{dim}"));
#>

using System;
using ResoniteLink;
using System.Collections.Generic;
using System.Linq;

public static class FieldArrayConverter
{
    public static Field ToResoniteLinkField<T>(this T value)
    {
        var type = typeof(T);

        if(Nullable.GetUnderlyingType(type)?.IsEnum == true)
        {
            return new Field_Nullable_Enum() 
            {
                Value = value?.ToString()  
            };
        }
        else if(type.IsEnum)
        {
            return new Field_Enum() 
            {
                Value = value.ToString()  
            };
        }

        // Unity Primitives (and our extensions)
        <#
        foreach(var type in unityPrimitives)
        {
            #>
            if(value is UnityEngine.<#=type#> value_<#=type#>)
                return value_<#=type#>.ToResoniteLink().ToResoniteLinkField();
            if(type == typeof(UnityEngine.<#=type#>?))
                return (value as UnityEngine.<#=type#>?)?.ToResoniteLink().ToResoniteLinkField();

            <#
        }
        #>

            // All other primitives
        <#
        foreach(var type in primitiveTypes)
        {
            #>
            if(type == typeof(<#=type#>))
            {
                var field = new Field_<#=type#>();
                field.BoxedValue = value;
                return field;
            }

            <#
            if(!nonNullableTypes.Contains(type))
            {
                #>                
                if(type == typeof(<#=type#>?))
                {
                    var field = new Field_Nullable_<#=type#>();
                    field.BoxedValue = value;
                    return field;
                }
                <#
            }
            #>

            <#
        }
        #>

        throw new NotSupportedException($"Unsupported value type: {typeof(T).FullName}");
    }

    public static SyncArray ToResoniteLinkArray<T>(this IEnumerable<T> values)
    {
        var type = typeof(T);

        // Unity Primitives (and our extensions)
        <#
        foreach(var type in unityPrimitives)
        {
            #>
            if(values is IEnumerable<UnityEngine.<#=type#>> values_<#=type#>)
                return values_<#=type#>.Select(v => v.ToResoniteLink()).ToResoniteLinkArray();
            <#
        }
        #>

        // All other primitives
        <#
        foreach(var type in primitiveTypes)
        {
            #>
            if(type == typeof(<#=type#>))
            {
                var array = new Array_<#=type#>();
                array.Values = values.Cast<<#=type#>>().ToList();
                return array;
            }
            <#
        }
        #>

        throw new NotSupportedException($"Unsupported value type: {typeof(T).FullName}");
    }
}